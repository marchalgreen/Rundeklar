# Engineering Guidelines Bundle

> Generated from guidelines.manifest.json. Do not edit this file manually.

Sources (in precedence order):
- prompts/agentPrompts/guards.md
- packages/webapp/ARCHITECTURE.md
- packages/webapp/CODE_ORGANIZATION_GUIDE.md
- packages/webapp/RESPONSIVE_DESIGN_GUIDE.md
- packages/webapp/AlwaysWorks.md

---

<!-- Source: prompts/agentPrompts/guards.md -->

üß± Clairity Guardrails

These guardrails define the non-negotiable engineering constraints for the Clairity Desktop-Web codebase.
They ensure maintainability, data safety, and design consistency across all epics.

‚∏ª

üß© Architecture & File Structure
‚Ä¢ Never move files across domains (components/, store/, lib/, etc.) without stating why in the epic plan.
‚Ä¢ New UI components:
‚Ä¢ Shared UI ‚Üí src/components/
‚Ä¢ Windows ‚Üí src/components/windows/
‚Ä¢ Never delete or rename files silently. All removals or renames must be called out in the plan or PR summary.
‚Ä¢ Prefer composition over duplication. If multiple windows share logic, extract to /lib or a shared hook.

‚∏ª

üé® Styling & Design System
‚Ä¢ Use Tailwind v4 tokens (see design-tokens.md and tailwind.config.ts).
‚Ä¢ No hard-coded hex values. Use tokens or semantic Tailwind utilities.
‚Ä¢ Use shadcn/ui primitives and lucide-react icons for all new UI.
‚Ä¢ No new UI libraries or design systems unless explicitly justified and approved in the epic plan.
‚Ä¢ Respect macOS/Tahoe visual identity ‚Äî radius, shadows, glass, focus rings.
‚Ä¢ Hairlines use rings, not borders:
‚Ä¢ ‚úÖ `ring-1 ring-[hsl(var(--line)/.12)]`
‚Ä¢ ‚ùå `border-[hsl(var(--line))]`

üì± Responsive Design (CRITICAL)
‚Ä¢ **ALL UI components MUST be responsive by default.** This is non-negotiable.
‚Ä¢ **Mobile-first approach**: Always start with mobile styles, then enhance for larger screens.
‚Ä¢ **Standard breakpoints**: Use Tailwind's `sm:` (640px), `md:` (768px), `lg:` (1024px), `xl:` (1280px).
‚Ä¢ **Device targets**: Mobile (0-639px), Tablet (640-1023px), Desktop (1024px+).
‚Ä¢ **Responsive spacing**: Use responsive padding/margins (`px-4 sm:px-6 md:px-8`).
‚Ä¢ **Responsive typography**: Scale text sizes appropriately (`text-sm sm:text-base md:text-lg`).
‚Ä¢ **Responsive layouts**: Grids and flex layouts must adapt (`grid-cols-1 sm:grid-cols-2 lg:grid-cols-3`).
‚Ä¢ **Touch targets**: Buttons/links must be at least 44px on mobile (`px-3 py-2` minimum).
‚Ä¢ **Testing requirement**: Test at 375px, 768px, 1024px, 1280px before committing.
‚Ä¢ **No fixed widths**: Never use fixed pixel widths without responsive alternatives.
‚Ä¢ **No desktop-only layouts**: Always provide mobile/tablet alternatives.
‚Ä¢ See RESPONSIVE_DESIGN_GUIDE.md for complete patterns and examples.
‚Ä¢ ‚ùå `className="w-[620px] px-6"` (fixed width, no responsive)
‚Ä¢ ‚úÖ `className="w-full sm:max-w-[620px] px-4 sm:px-6"` (responsive)

‚∏ª

üßæ Docs & Documentation System
‚Ä¢ All docs pages must render inside the unified layout (`UnifiedDocLayout`) via a section-level `layout.tsx`.
‚Ä¢ Sidebar navigation is driven by `src/components/docs/nav/index.ts` and presets ‚Äî never hardcoded per page.
‚Ä¢ Each docs change originates from a single **Epic** (`docs/epics/<Module>/EPIC-<module>.md`).
‚Ä¢ When regenerating docs:
‚Ä¢ Backup ‚Üí `docs/_trash/<module>-<timestamp>/`
‚Ä¢ Clear ‚Üí `src/app/docs/<module>/**` (keep layout.tsx)
‚Ä¢ Scaffold ‚Üí Overview, Quickstart, UI Guide, API pages via Codex task.
‚Ä¢ Swagger pages must always embed live specs:
‚Ä¢ `/docs/<module>/api/swagger` ‚Üí `/api/docs/swagger?spec=/api/docs/<module>.json`
‚Ä¢ Specs live under `src/lib/docs/*OpenAPI.ts` and are served by `/api/docs/<module>.json`.
‚Ä¢ No guessed endpoints or manual Swagger HTML.
‚Ä¢ Sidebar links may never point to non-existent pages. Remove or add placeholders instead of leaving 404s.
‚Ä¢ All docs use Tailwind tokens ‚Äî rings, surfaces, and HSL vars. No hex or raw borders.
‚Ä¢ All docs PRs must include validation:

1. `pnpm run validate`
2. Manual smoke on `/docs/<module>` routes (sidebar + pages)
3. Swagger embed renders successfully.

‚∏ª

üóÉÔ∏è Database / Prisma
‚Ä¢ No schema or model edits unless explicitly defined in the plan.
Each DB-touching epic must include:
‚Ä¢ Migration name
‚Ä¢ Model diffs (old vs new)
‚Ä¢ Data migration or backfill strategy
‚Ä¢ Commands for local and production runs
‚Ä¢ Commands must be included in the PR body:

pnpm prisma migrate dev --name <name>
pnpm prisma migrate deploy

‚Ä¢ Never commit secrets, connection strings, or real URLs.
‚Ä¢ .env keys must remain documented but values must be safe placeholders.

‚∏ª

üß™ Build & Quality Gates
‚Ä¢ All PRs must pass: 1. pnpm run validate ‚Üí typecheck + lint 2. pnpm build ‚Üí includes Prisma generate and Next build
‚Ä¢ Maintain path-safe imports. No circular dependencies.
‚Ä¢ Respect TypeScript strict mode.
‚Ä¢ No any unless wrapped in a typed alias with a // TODO: refine note.
‚Ä¢ Ensure new files pass Prettier and ESLint automatically.

‚∏ª

üìù Code Comments & JSDoc (CRITICAL)
‚Ä¢ **JSDoc is required** for all exported functions, classes, components, hooks, and services.
‚Ä¢ Comment for intent, invariants, and non-obvious rationale ‚Äî never restate what the code already says.
‚Ä¢ Hooks must document inputs, returned shape, side effects, and error handling pattern.
‚Ä¢ Services must document inputs/outputs, invariants, and edge cases; keep functions pure where possible.
‚Ä¢ API functions must document request/response shapes and expected errors.
‚Ä¢ Module-level README must be added/updated when introducing new modules or significant features.
‚Ä¢ Keep comments concise and up to date; remove stale comments during refactors.

Example JSDoc:
```ts
/**
 * Creates a new player.
 * @param input - Player creation data
 * @returns Created player with generated ID
 * @throws {AppError} On validation or persistence failure
 */
export async function createPlayer(input: PlayerCreateInput): Promise<Player> { ... }
```

‚∏ª

‚ôø Accessibility & Localization
‚Ä¢ Maintain logical focus order and visible focus rings.
‚Ä¢ All interactive elements must be keyboard-navigable.
‚Ä¢ Default copy language: Danish (da-DK).
‚Ä¢ Keep labels short, clear, and clinical in tone.
‚Ä¢ If adding new text, ensure it‚Äôs ready for localization (no hardcoded inline text in logic).

‚∏ª

‚ö° Performance
‚Ä¢ Avoid blocking hydration with expensive sync logic.
‚Ä¢ Lazy-load heavy components or data when possible.
‚Ä¢ Limit Framer Motion use to short, low-impact transitions.
‚Ä¢ Respect prefers-reduced-motion.
‚Ä¢ Defer analytics or non-critical network requests until post-mount.

‚∏ª

ü™ü Windowing & Desktop Behavior
‚Ä¢ Never break or bypass Window component behavior:
‚Ä¢ Snap zones
‚Ä¢ Minimize animations
‚Ä¢ Titlebar buttons
‚Ä¢ Window focus/blur states
‚Ä¢ Do not mutate the global desktop Zustand shape without prior approval.
‚Ä¢ Follow useDesktop() conventions for opening, focusing, and minimizing windows.
‚Ä¢ Keep window chrome consistent across all windowed experiences.

‚∏ª

üîí Security & Data Integrity
‚Ä¢ Never log secrets or personally identifiable information (PII).
‚Ä¢ Always sanitize external or user-generated input using zod schemas.
‚Ä¢ When handling IDs (e.g., scanned barcodes), validate format and sanitize before storage or lookup.
‚Ä¢ Avoid leaking internal identifiers to client logs or external APIs.
‚Ä¢ All fetches to vendor or network APIs must include error handling and safe fallbacks.

‚∏ª

üõ°Ô∏è Code Organization & Best Practices

**CRITICAL: Think architecturally. Always consider separation of concerns, modularization, and where code should live.**

‚Ä¢ **Architectural Thinking First** ‚Äî Before writing code, think about:
  - Where should this code live? (component, hook, service, utility, API layer?)
  - Is this logic reusable? (extract to hook/service/utility)
  - Does this belong in the current file or should it be extracted?
  - What is the separation of concerns? (UI, business logic, data access)
  - Should this be a new file or added to existing?

‚Ä¢ **Error Handling Best Practices** ‚Äî Use centralized error handling for consistency:
  - **User-facing errors**: Always use `normalizeError` from `src/lib/errors.ts`
  - **Error normalization**: Use `normalizeError(err)` instead of manual extraction
  - **Error display**: Use `normalizedError.message` for user messages via toast notifications
  - **Pattern**: Follow the pattern in `usePlayers`, `useSession`, `useCheckIns` hooks
  - **Local handling**: Only when you need component-specific error state that doesn't need user notification
  - ‚ùå `catch (err) { const msg = err instanceof Error ? err.message : 'Error' }`
  - ‚úÖ `catch (err) { const normalizedError = normalizeError(err); notify({ variant: 'danger', title: '...', description: normalizedError.message }) }`

‚Ä¢ **Code Modularization** ‚Äî Extract and organize code properly:
  - **Reusable logic** ‚Üí Extract to hooks (`src/hooks/`)
  - **Pure business logic** ‚Üí Extract to services (`src/services/` or `src/lib/`)
  - **Formatting/validation** ‚Üí Use existing utilities (`src/lib/formatting.ts`, `src/lib/validation.ts`)
  - **Constants** ‚Üí Use centralized constants (`src/constants/index.ts`)
  - **Complex components** ‚Üí Break into sub-components (`src/components/[feature]/`)
  - **Data fetching** ‚Üí Use existing hooks or create new ones following the pattern

‚Ä¢ **Before Writing Code Checklist**:
  1. **Where should this code live?** (component, hook, service, utility, API?)
  2. **Does similar code already exist?** (check hooks, services, utilities)
  3. **Is this reusable?** (extract if yes)
  4. **What's the separation of concerns?** (UI vs logic vs data)
  5. **Should this be a new file?** (if it's a new concern/feature)
  6. **What pattern do similar features use?** (review existing code)

‚Ä¢ **File Organization Principles**:
  - **Single Responsibility**: Each file should have one clear purpose
  - **Separation of Concerns**: UI components don't contain business logic
  - **Reusability**: Extract reusable logic to hooks/services/utilities
  - **Discoverability**: Code should be easy to find (follow existing structure)
  - **Maintainability**: Changes should be localized (modular structure)

‚Ä¢ **When User Suggests Changes**:
  - **Think about architecture**: Where should this code live?
  - **Consider existing patterns**: How is similar functionality implemented?
  - **Propose structure**: Suggest file organization if needed
  - **Extract if needed**: Don't just add to existing file if it violates separation of concerns
  - **Ask if unclear**: If unsure about architecture, propose options

‚Ä¢ **NO console.log/console.error in production code**:
  - ‚ùå `console.log('Debug:', data)` or `console.error('Error:', err)`
  - ‚úÖ Use `normalizeError` and toast notifications for user-facing errors
  - ‚úÖ Use proper logging infrastructure if needed (not console.*)

‚∏ª

üß† Principle

Clairity code is surgical, auditable, and reversible.
If a change can't be cleanly rolled back, it's too large for a single epic.
**Never create local solutions when centralized patterns exist.**

---

<!-- Source: packages/webapp/ARCHITECTURE.md -->

# Application Architecture

Note on precedence: This document defers to `prompts/agentPrompts/guards.md` for non‚Äënegotiable rules. If guidance here conflicts, the guardrails win. For responsive rules, see the canonical `packages/webapp/RESPONSIVE_DESIGN_GUIDE.md`.

## Overview

This application is a multi-tenant badminton training management system built with React, TypeScript, and Supabase. It follows a modular, layered architecture with clear separation of concerns.

## Architecture Layers

### 1. Presentation Layer (`src/routes/`, `src/components/`)

**Purpose**: User interface components and page-level routes.

**Structure**:
- `routes/` - Page-level components (CheckIn, PlayersDB, MatchProgram, Statistics)
- `components/ui/` - Reusable UI primitives (Button, Table, Badge, etc.)
- `components/navigation/` - Navigation-specific components

**Principles**:
- Components should be focused and single-purpose
- Extract complex logic into custom hooks
- Use composition over inheritance
- Keep components under 300 lines when possible
- All new UI must be mobile-first responsive. Follow `RESPONSIVE_DESIGN_GUIDE.md` and test at 375px, 768px, 1024px, and 1280px before committing.

### 2. Business Logic Layer (`src/hooks/`, `src/services/`)

**Purpose**: Custom hooks and service functions that encapsulate business logic.

**Structure**:
- `hooks/` - Custom React hooks for data fetching, state management, and business logic
- `services/` - Pure business logic functions (matchmaking, validation, calculations)

**Principles**:
- Hooks handle component-specific state and side effects
- Services are pure functions (no side effects, easily testable)
- Business rules live here, not in components or API layer

### 3. API Layer (`src/api/`)

**Purpose**: Data access and external service integration.

**Structure**:
- `api/index.ts` - Main API client with domain-specific modules
- `api/supabase.ts` - Supabase client configuration
- `api/stats.ts` - Statistics-specific API functions
- `api/storage.ts` - Storage operations

**Principles**:
- All data access goes through this layer
- Handles data transformation (DB format ‚Üî Domain format)
- Provides consistent error handling
- No business logic in API layer

### 4. Data Access Layer (`src/lib/supabase.ts`)

**Purpose**: Low-level database operations and Supabase client management.

**Structure**:
- `lib/supabase.ts` - Supabase client creation and tenant management
- `lib/tenant.ts` - Tenant configuration and path utilities

**Principles**:
- Only database operations and client management
- No business logic
- Handles tenant isolation

### 5. Domain Layer (`@herlev-hjorten/common`)

**Purpose**: Shared types and domain models.

**Structure**:
- Type definitions for entities (Player, Match, Session, etc.)
- Shared constants and enums

**Principles**:
- Single source of truth for types
- No implementation details
- Shared across packages

## Data Flow

```
User Action
  ‚Üì
Component (Presentation)
  ‚Üì
Custom Hook (Business Logic)
  ‚Üì
API Service (Data Access)
  ‚Üì
Supabase Client (Database)
  ‚Üì
Response flows back up
```

## Key Patterns

### 1. Custom Hooks Pattern

Extract component logic into reusable hooks:

```typescript
// ‚ùå Bad: Logic in component
const Component = () => {
  const [data, setData] = useState([])
  const [loading, setLoading] = useState(false)
  useEffect(() => {
    // complex logic here
  }, [])
  // ...
}

// ‚úÖ Good: Logic in hook
const usePlayers = () => {
  const [data, setData] = useState([])
  const [loading, setLoading] = useState(false)
  // complex logic here
  return { data, loading, refetch }
}

const Component = () => {
  const { data, loading } = usePlayers()
  // ...
}
```

### 2. Service Layer Pattern

Pure business logic functions:

```typescript
// services/matchmaker.ts
export const createMatchAssignments = (
  players: Player[],
  courts: Court[]
): MatchAssignment[] => {
  // Pure function, easily testable
  // No side effects
}
```

### 3. Error Handling Pattern

**Best Practice: Use centralized error handling for user-facing errors. Use local error state only for UI-specific validation that doesn't need user notification.**

Centralized error handling:

```typescript
// lib/errors.ts
import { normalizeError } from '../lib/errors'
import { useToast } from '../components/ui/Toast'

// ‚ùå BAD: Local error handling
try {
  await api.players.update(...)
} catch (err) {
  const msg = err instanceof Error ? err.message : 'Error'
  console.error('Error:', err)
  notify({ variant: 'danger', title: 'Error', description: msg })
}

// ‚úÖ GOOD: Centralized error handling (follow this pattern)
try {
  await api.players.update(...)
} catch (err) {
  const normalizedError = normalizeError(err)
  notify({
    variant: 'danger',
    title: 'Kunne ikke opdatere spiller',
    description: normalizedError.message
  })
}
```

**Pattern to follow:**
1. Import `normalizeError` from `src/lib/errors.ts`
2. Use `normalizeError(err)` in all catch blocks
3. Use `normalizedError.message` for user-facing messages
4. Never use `console.log` or `console.error` in production code
5. Follow the exact pattern used in `usePlayers`, `useSession`, `useCheckIns` hooks

**Reference implementations:**
- `src/hooks/usePlayers.ts` - See `createPlayer`, `updatePlayer` methods
- `src/hooks/useSession.ts` - See `startSession`, `endSession` methods
- `src/hooks/useCheckIns.ts` - See `checkIn`, `checkOut` methods

### 4. Type Safety Pattern

Strict typing throughout:

```typescript
// ‚ùå Bad
const handleSubmit = (data: any) => { }

// ‚úÖ Good
interface PlayerFormData {
  name: string
  alias?: string
  levelSingle?: number
}

const handleSubmit = (data: PlayerFormData) => { }
```

## File Organization

### Component Structure

```
ComponentName/
  ‚îú‚îÄ‚îÄ ComponentName.tsx       # Main component
  ‚îú‚îÄ‚îÄ ComponentName.test.tsx  # Tests
  ‚îú‚îÄ‚îÄ useComponentName.ts     # Custom hook (if needed)
  ‚îú‚îÄ‚îÄ types.ts                # Component-specific types
  ‚îî‚îÄ‚îÄ constants.ts            # Component-specific constants
```

### Service Structure

```
services/
  ‚îú‚îÄ‚îÄ players/
  ‚îÇ   ‚îú‚îÄ‚îÄ playerService.ts    # Player business logic
  ‚îÇ   ‚îú‚îÄ‚îÄ playerValidation.ts # Validation rules
  ‚îÇ   ‚îî‚îÄ‚îÄ types.ts            # Service-specific types
  ‚îî‚îÄ‚îÄ matches/
      ‚îú‚îÄ‚îÄ matchService.ts
      ‚îî‚îÄ‚îÄ matchmaker.ts
```

## Testing Strategy

### Unit Tests
- Services: Pure functions, easy to test
- Hooks: Use `@testing-library/react-hooks`
- Utilities: Direct function calls

### Integration Tests
- API layer: Mock Supabase client
- Custom hooks: Test with real API mocks

### E2E Tests
- Critical user flows
- Use Playwright for browser automation

## Performance Considerations

1. **Memoization**: Use `useMemo` and `useCallback` for expensive computations
2. **Code Splitting**: Lazy load routes with `React.lazy`
3. **Virtualization**: Use `react-window` for long lists
4. **Debouncing**: Debounce search inputs and API calls

## Security Considerations

1. **Tenant Isolation**: All queries scoped to tenant
2. **Input Validation**: Validate all user inputs with Zod
3. **Error Messages**: Don't expose sensitive information in errors
4. **Type Safety**: Use TypeScript to prevent type-related vulnerabilities

## Documentation Standards

All new code must include documentation that matches existing conventions across the app. JSDoc on exported APIs is mandatory.

### JSDoc Comments

All exported functions, classes, and components should have JSDoc:

```typescript
/**
 * Creates a new player in the system.
 * 
 * @param input - Player creation data
 * @returns Created player with generated ID
 * @throws {AppError} If validation fails or player already exists
 * 
 * @example
 * ```typescript
 * const player = await createPlayer({
 *   name: 'John Doe',
 *   levelSingle: 5
 * })
 * ```
 */
export const createPlayer = async (input: PlayerCreateInput): Promise<Player> => {
  // implementation
}
```

### Component, Hook, and Service Documentation

- Components: Document props (with `@prop`), responsibilities, and any non-obvious UI behavior.
- Hooks: Document inputs, return shape, side effects, and error normalization pattern.
- Services: Document purpose, inputs/outputs, invariants, and performance/edge-case notes.
- API layer: Document request/response shape and expected error cases.

### README Files

Each major module should have a README explaining:
- Purpose and responsibility
- Usage examples
- API reference
- Common patterns

## Migration Guide

When refactoring existing code:

1. **Identify boundaries**: Separate presentation, business logic, and data access
2. **Extract incrementally**: Move logic piece by piece, test after each change
3. **Maintain compatibility**: Keep existing APIs working during transition
4. **Update tests**: Add tests for new structure
5. **Document changes**: Update architecture docs and READMEs

## Future Improvements

1. **State Management**: Consider Zustand for complex global state
2. **Form Handling**: Standardize on react-hook-form + Zod
3. **API Client**: Consider tRPC for type-safe APIs
4. **Component Library**: Build a design system component library
5. **Storybook**: Add Storybook for component documentation

---

<!-- Source: packages/webapp/CODE_ORGANIZATION_GUIDE.md -->

# Code Organization & Best Practices Guide

Canonical sources and precedence:
- Non‚Äënegotiable guardrails: `prompts/agentPrompts/guards.md`
- Responsive design (canonical): `packages/webapp/RESPONSIVE_DESIGN_GUIDE.md`
- If this guide conflicts with the above, the canonical docs win.

## Core Principles

### 1. Architectural Thinking First

**Before writing any code, ask yourself:**

1. **Where should this code live?**
   - Component? (`src/components/`)
   - Hook? (`src/hooks/`)
   - Service/Utility? (`src/lib/` or `src/services/`)
   - API layer? (`src/api/`)
   - Constants? (`src/constants/`)

2. **Is this logic reusable?**
   - If yes ‚Üí Extract to hook/service/utility
   - If no ‚Üí Keep in component if it's UI-specific

3. **What's the separation of concerns?**
   - **UI/Presentation** ‚Üí Components
   - **Business Logic** ‚Üí Hooks/Services
   - **Data Access** ‚Üí API layer
   - **Pure Functions** ‚Üí Services/Utilities

4. **Should this be a new file?**
   - New feature/concern ‚Üí New file
   - Extension of existing ‚Üí Add to existing file
   - Related functionality ‚Üí Consider grouping

### 2. Responsive by Default

- All new UI must be built mobile-first and be responsive across breakpoints.
- Use Tailwind responsive modifiers (`sm:`, `md:`, `lg:`, `xl:`) for spacing, typography, and layout.
- Avoid fixed widths without responsive alternatives; prefer fluid widths with max-w on larger screens.
- Verify no horizontal overflow and adequate touch targets on mobile.
- See `RESPONSIVE_DESIGN_GUIDE.md` for patterns and the pre-commit checklist (375px, 768px, 1024px, 1280px).

### 3. Documentation & Comments

- JSDoc is required for all exported functions, classes, components, hooks, and services.
- Comment for intent and invariants, not obvious code. Prefer clear names over redundant comments.
- Keep comments concise; document non-obvious rationale, edge cases, and performance caveats.
- Hooks must document inputs, returned shape, and side effects.
- Services must document inputs/outputs and invariants; keep pure when possible.
- API functions must document request/response shapes and error cases.
- Add or update module README when introducing new modules or major features.

```typescript
/**
 * Loads players list filtered by optional criteria.
 *
 * @param filters - Optional list filters (query, active flag)
 * @returns Players matching filters
 * @throws {AppError} On API failures; see normalizeError for details
 */
export async function listPlayers(filters?: PlayerListFilters): Promise<Player[]> { ... }
```

## Code Organization Patterns

### Component Structure

```typescript
// ‚úÖ GOOD: Component focuses on UI, delegates logic to hooks
import { usePlayers } from '../hooks'

const PlayersPage = () => {
  const { players, loading, error, createPlayer, updatePlayer } = usePlayers()
  
  // UI rendering only
  return <div>...</div>
}

// ‚ùå BAD: Component contains business logic
const PlayersPage = () => {
  const [players, setPlayers] = useState([])
  const [loading, setLoading] = useState(false)
  
  useEffect(() => {
    // Complex data fetching logic here
    // This should be in a hook!
  }, [])
  
  return <div>...</div>
}
```

### Hook Pattern

```typescript
// ‚úÖ GOOD: Hook encapsulates data fetching and business logic
export const usePlayers = (filters?: PlayerListFilters) => {
  const [players, setPlayers] = useState<Player[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const { notify } = useToast()

  const loadPlayers = useCallback(async () => {
    setLoading(true)
    setError(null)
    
    try {
      const result = await api.players.list(filters)
      setPlayers(result)
    } catch (err) {
      const normalizedError = normalizeError(err)
      setError(normalizedError.message)
      notify({
        variant: 'danger',
        title: 'Kunne ikke hente spillere',
        description: normalizedError.message
      })
    } finally {
      setLoading(false)
    }
  }, [filters?.q, filters?.active, notify])

  // ... more methods

  return { players, loading, error, createPlayer, updatePlayer, refetch: loadPlayers }
}
```

### Service/Utility Pattern

```typescript
// ‚úÖ GOOD: Pure function, easily testable, reusable
// src/lib/matchmaker.ts
export const createMatchAssignments = (
  players: Player[],
  courts: Court[]
): MatchAssignment[] => {
  // Pure business logic
  // No side effects
  // Easy to test
}

// ‚ùå BAD: Business logic in component
const Component = () => {
  const createMatches = () => {
    // Complex business logic here
    // This should be in a service!
  }
}
```

### ... more content from the original guide ...

---

<!-- Source: packages/webapp/RESPONSIVE_DESIGN_GUIDE.md -->

# üì± Responsive Design System Guide

Canonical: This guide is the source of truth for responsiveness. For overall rule precedence, see the ‚ÄúEngineering Guidelines Index‚Äù in `README.md` and `prompts/agentPrompts/guards.md`.

**CRITICAL:** All UI components MUST be built with responsive design in mind from the start. This is not optional.

## üéØ Core Principle: Mobile-First Design

**Always design for the smallest screen first, then enhance for larger screens.**

- ‚úÖ Start with mobile styles (base classes)
- ‚úÖ Add responsive modifiers for larger screens (`sm:`, `md:`, `lg:`, `xl:`)
- ‚ùå Never assume desktop-only usage
- ‚ùå Never use fixed widths without responsive alternatives

### ... content truncated for brevity ...

---

<!-- Source: packages/webapp/AlwaysWorks.md -->

---

description: Ensure what you implement Always Works‚Ñ¢ in the Herlev Hjorten webapp
---

# How to ensure **Always Works‚Ñ¢** implementation

Note on precedence: For guardrails, see `prompts/agentPrompts/guards.md`. This checklist complements, and does not override, the canonical guardrails or the `RESPONSIVE_DESIGN_GUIDE.md`.

Please ensure your implementation Always Works‚Ñ¢ for: **$ARGUMENTS**  
_(e.g. ‚ÄúCheck-in flow‚Äù, ‚ÄúMatch auto-arrange‚Äù, ‚ÄúPlayer CRUD‚Äù, ‚ÄúStatistics aggregation‚Äù, etc.)_

Follow this systematic approach.

## The 30-Second Reality Check (must answer **YES** to all)

- [ ] **Built it:** `pnpm build` is green, `pnpm lint` passes, and `pnpm test` is green.
- [ ] **Ran it:** `pnpm dev` is running (Vite on :5173; preview on :4173).
- [ ] **Triggered it:** I exercised the exact UI/route/config I changed (clicked the button / hit the endpoint / restarted the server).
- [ ] **Observed it:** I saw the expected UI or `curl`/log output with my own eyes and pasted a snippet in the PR.
- [ ] **Error paths:** I forced at least one failure case and saw a clear, actionable error (e.g. validation toast, disabled action, or logged AppError).
- [ ] **Config holds:** Tenant config from `src/config/tenants/*.json` is loaded/applied (branding, courts count, categories) and survives reload.
- [ ] **I‚Äôd bet ‚Ç¨100 this works.**
 - [ ] **Documented it:** All exported functions/classes/components updated with JSDoc; module README added/updated if introducing a new module.

## Specific Test Requirements

- **UI changes:** Start the app, navigate to the affected route, click the control, and observe DOM/state:
  - `CheckIn`: add players, check in/out, verify letter filters and counts.
  - `MatchProgram`: auto-arrange or manual move; verify assignments and leftover bench.
  - `PlayersDB`: create/edit/delete player; validate partner edit and form validation.
  - `Statistics`: confirm totals update after actions.
- **Responsive checks (required for UI changes):**
  - [ ] Mobile 375px (iPhone SE): no horizontal overflow, readable text, tappable buttons (‚â•44px).
  - [ ] Tablet 768px (iPad portrait): layouts adapt (grids/stacking), comfortable spacing.
  - [ ] Tablet 1024px (iPad landscape): multi-column layouts and headers align.
  - [ ] Desktop 1280px+: optimal spacing, no fixed-width overflow.
  - [ ] Uses mobile-first classes with responsive modifiers (`sm:`, `md:`, `lg:`).
  - See `RESPONSIVE_DESIGN_GUIDE.md` for full patterns and the pre-commit checklist.
 - **Documentation checks (required for all changes):**
   - [ ] JSDoc present on all new or modified exported functions/classes/components/hooks/services.
   - [ ] Hook docs describe inputs, return shape, side effects, and error handling.
   - [ ] API docs describe request/response shapes and error cases.
   - [ ] Module README added/updated when introducing or significantly changing a module.
- **Logic changes:** Run unit tests (`pnpm test`). Add/extend tests under `packages/webapp/tests/` (e.g., `matchmaker.test.ts`) for new edge cases. Reproduce the scenario end-to-end in the UI.
- **Data/Supabase changes:** Ensure `.env.local` is configured and the SQL migration is applied (see Supabase section). Verify changes in Supabase Table Editor after UI actions.
- **Config changes:** Modify `src/config/tenants/*.json`, restart dev server, and verify branding/court settings are reflected. Rebuild to ensure configs are copied to `dist/`.


